if ( xTreatment[rloop] == 2){
numberOfB = numberOfB + 1
}
if ( xTreatment[rloop] == 1 & xResult[rloop] == 1){
Asuccess = Asuccess + 1
}
if ( xTreatment[rloop] == 2 & xResult[rloop] == 1){
Bsuccess = Bsuccess + 1
}
}
AsuccessProp = Asuccess / numberOfA
BsuccessProp = Bsuccess / numberOfB
if ( AsuccessProp >= ( BsuccessProp * 2 ) ){
count = count + 1
}
}
count/nloop
numberOfA
Asuccess
nloop=10000
count=0
for(iloop in 1:nloop){
Asuccess = 0
Bsuccess = 0
numberOfA = 0
numberOfB = 0
xTreatment=sample(1:3,40,replace=TRUE)
xResult=sample(0:1,40,replace=TRUE,prob=c(.8,.2)
for(rloop in 1:40){
if ( xTreatment[rloop] == 1){
numberOfA = numberOfA + 1
}
if ( xTreatment[rloop] == 2){
numberOfB = numberOfB + 1
}
if ( xTreatment[rloop] == 1 & xResult[rloop] == 1){
Asuccess = Asuccess + 1
}
if ( xTreatment[rloop] == 2 & xResult[rloop] == 1){
Bsuccess = Bsuccess + 1
}
}
AsuccessProp = Asuccess / numberOfA
BsuccessProp = Bsuccess / numberOfB
if ( AsuccessProp >= ( BsuccessProp * 2 ) ){
count = count + 1
}
print("here")
}
count/nloop
nloop=10000
count=0
for(iloop in 1:nloop){
Asuccess = 0
Bsuccess = 0
numberOfA = 0
numberOfB = 0
xTreatment=sample(1:3,40,replace=TRUE)
xResult=sample(0:1,40,replace=TRUE,prob=c(.8,.2)
for(rloop in 1:40){
if ( xTreatment[rloop] == 1){
numberOfA = numberOfA + 1
}
if ( xTreatment[rloop] == 2){
numberOfB = numberOfB + 1
}
if ( xTreatment[rloop] == 1 & xResult[rloop] == 1){
Asuccess = Asuccess + 1
}
if ( xTreatment[rloop] == 2 & xResult[rloop] == 1){
Bsuccess = Bsuccess + 1
}
}
AsuccessProp = Asuccess / numberOfA
BsuccessProp = Bsuccess / numberOfB
if ( AsuccessProp >= ( BsuccessProp * 2 ) ){
count = count + 1
}
print("here")
}
count/nloop
nloop=10000
count=0
for(iloop in 1:nloop){
Asuccess = 0
Bsuccess = 0
numberOfA = 0
numberOfB = 0
xTreatment=sample(1:3,40,replace=TRUE)
xResult=sample(0:1,40,replace=TRUE,prob=c(.8,.2)
for(rloop in 1:40){
if ( xTreatment[rloop] == 1){
numberOfA = numberOfA + 1
}
if ( xTreatment[rloop] == 2){
numberOfB = numberOfB + 1
}
if ( xTreatment[rloop] == 1 & xResult[rloop] == 1){
Asuccess = Asuccess + 1
}
if ( xTreatment[rloop] == 2 & xResult[rloop] == 1){
Bsuccess = Bsuccess + 1
}
}
AsuccessProp = Asuccess / numberOfA
BsuccessProp = Bsuccess / numberOfB
if ( AsuccessProp >= ( BsuccessProp * 2 ) ){
count = count + 1
}
print("here")
}
count/nloop
nloop=10000
count=0
for(iloop in 1:nloop){
numberOfA = 0
numberOfB = 0
Asuccess = 0
Bsuccess = 0
xTreatment=sample(1:3,40,replace=TRUE)
xResult=sample(0:1,40,replace=TRUE,prob=c(.8,.2)
for(rloop in 1:40){
if ( xTreatment[rloop] == 1){
numberOfA = numberOfA + 1
}
if ( xTreatment[rloop] == 2){
numberOfB = numberOfB + 1
}
if ( xTreatment[rloop] == 1 & xResult[rloop] == 1){
Asuccess = Asuccess + 1
}
if ( xTreatment[rloop] == 2 & xResult[rloop] == 1){
Bsuccess = Bsuccess + 1
}
}
AsuccessProp = Asuccess / numberOfA
BsuccessProp = Bsuccess / numberOfB
if ( AsuccessProp >= ( BsuccessProp * 2 ) ){
count = count + 1
}
print("here")
}
count/nloop
nloop=10000
count=0
for(iloop in 1:nloop){
}
count/nloop
nloop=10000
count=0
for(iloop in 1:nloop){
numberOfA = 0
numberOfB = 0
Asuccess = 0
Bsuccess = 0
}
count/nloop
nloop=10000
count=0
for(iloop in 1:nloop){
numberOfA = 0
numberOfB = 0
Asuccess = 0
Bsuccess = 0
xTreatment=sample(1:3,40,replace=TRUE)
xResult=sample(0:1,40,replace=TRUE,prob=c(.8,.2)
}
count/nloop
nloop=10000
count=0
for(iloop in 1:nloop){
numberOfA = 0
numberOfB = 0
Asuccess = 0
Bsuccess = 0
xTreatment=sample(1:3,40,replace=TRUE)
xResult=sample(0:1,40,replace=TRUE,prob=c(.8,.2))
for(rloop in 1:40){
if ( xTreatment[rloop] == 1){
numberOfA = numberOfA + 1
}
if ( xTreatment[rloop] == 2){
numberOfB = numberOfB + 1
}
if ( xTreatment[rloop] == 1 & xResult[rloop] == 1){
Asuccess = Asuccess + 1
}
if ( xTreatment[rloop] == 2 & xResult[rloop] == 1){
Bsuccess = Bsuccess + 1
}
}
AsuccessProp = Asuccess / numberOfA
BsuccessProp = Bsuccess / numberOfB
if ( AsuccessProp >= ( BsuccessProp * 2 ) ){
count = count + 1
}
}
count/nloop
sample(0:1)
sample(0:1),1
sample(0:1,1)
sample(0:1,1)
if sample == 0{ print(sample)}
if (sample == 0 ){ print(sample)}
fail = sample(0:1,1)
fail
fail[1]
fail = sample(0:1,1)
fail[1]
nloop=10000
deviceFailure=0
for(iloop in 1:nloop){
xFilaments=sample(0:3,4,replace=TRUE,prob=c(.55,.25,.15,.05))
veryBadFils = 0
badFils = 0
for ( xloop in 1:4 ){
if ( xFilaments[xloop] == 3 ){
veryBadFils = veryBadFils + 1
}
if ( xFilaments[xloop] == 2 ){
badFils = badFils + 1
}
}
if ( veryBadFils >= 2 ){
deviceFailure = deviceFailure + 1
}else{
if ( badFils >= 1){
fail = sample(0:1,1)
if ( fail[1] == 1 )
deviceFailure = deviceFailure +1
}
}
}
deviceFailure/nloop
nloop=100000
deviceFailure=0
for(iloop in 1:nloop){
xFilaments=sample(0:3,4,replace=TRUE,prob=c(.55,.25,.15,.05))
veryBadFils = 0
badFils = 0
for ( xloop in 1:4 ){
if ( xFilaments[xloop] == 3 ){
veryBadFils = veryBadFils + 1
}
if ( xFilaments[xloop] == 2 ){
badFils = badFils + 1
}
}
if ( veryBadFils >= 2 ){
deviceFailure = deviceFailure + 1
}else{
if ( badFils >= 1){
fail = sample(0:1,1)
if ( fail[1] == 1 )
deviceFailure = deviceFailure +1
}
}
}
deviceFailure/nloop
nloop=1000000
deviceFailure=0
for(iloop in 1:nloop){
xFilaments=sample(0:3,4,replace=TRUE,prob=c(.55,.25,.15,.05))
veryBadFils = 0
badFils = 0
for ( xloop in 1:4 ){
if ( xFilaments[xloop] == 3 ){
veryBadFils = veryBadFils + 1
}
if ( xFilaments[xloop] == 2 ){
badFils = badFils + 1
}
}
if ( veryBadFils >= 2 ){
deviceFailure = deviceFailure + 1
}else{
if ( badFils >= 1){
fail = sample(0:1,1)
if ( fail[1] == 1 )
deviceFailure = deviceFailure +1
}
}
}
deviceFailure/nloop
library(caret)
library(kernlab)
data(spam)
typeof(spam)
inTrain = createDataPartition(y=spam$type,p=.75,list=FALSE)
head(inTrain)
typeof(inTrain)
training = spam[inTrain,]
typeof(training)
set.seed(32323)
testing = spam[-inTrain,]
typeof(testing)
set.seed(32323)
folds = createFolds(y=spam$type,k=10,list=TRUE,returnTrain=TRUE)
typeof(folds)
folds
sapply(folds,length)
head(folds)
folds[1][1:10]
folds[1]
folds[1][1:10]
dim(folds)
folds
type(folds)
typeos(folds)
typeof(folds)
typeof(spam)
names(list)
names(folds)
folds[[1]][1:10]
typeof(folds$Fold01)
sapply(folds,length)
typeof(folds)
typeof(folds[[1]])
typeof(folds[1])
folds[1]
folds[[1]]
folds[1]
install.packages("ISLR")
library(ISLR)
install.packages("gridExtra")
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
install.packages("AppliedPredictiveModeling")
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
names(training)
dim(training)
plot(training$CompressiveStrength)
plot(training$CompressiveStrength,pch=19)
qplot(training$CompressiveStrength,pch=19)
cutCS = cut2(training$CompressiveStrength,g=3)
install.packages("Hmisc")
plot(training$CompressiveStrength)
p1 <- qplot(cutCS,,data=training,fill=cutCS)
p1
cutCS = cut2(training$CompressiveStrength,g=4)
p1 <- qplot(cutCS,,data=training,fill=cutCS)
p1
cutCS = cut(training$CompressiveStrength,g=4)
p1 <- qplot(cutCS,,data=training,fill=cutCS)
p1
cutCS = cut2(training$CompressiveStrength,g=4)
cutCS = cut(training$CompressiveStrength,g=4)
library(Hmisc)
cutCS = cut2(training$CompressiveStrength,g=4)
p1 <- qplot(cutCS,,data=training,fill=cutCS)
p1
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
hist(training$SuperPlasticizer,main="")
head(training)
hist(training$SuperPlasticizer,main="",xlab="I don't know")
training
hist(training$Superplasticizer,main="",xlab="I don't know")
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
names(training)
smallSet <- training(,c(58:69))
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
smallSet <- training(,c(58:69))
smallSet <- training[],c(58:69)]
smallSet <- training[,(58:69)]
names(smallSet)
prComp <- prcomp(smallSet)
dim prComp
dim (prComp)
prComp
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
names(training)
help(AlzheimerDisease)
preProc <- preProcess(training,method="pca")
head(training)
dim(training)
preProc <- preProcess(smallSet,method="pca")
preProc
smallSet <- training[,(1,58:69)]
smallSet2 <- training[,1]
names(smallSet2)
smallSet2
names(smallSet)
smallSet2 <- training[,(1)]
names(smallSet2)
names(training)
smallSet2 <- training[,(1:1)]
smallSet2
newData = cbind(smallSet2,smallSet)
names(newData)
head(newData)
head(training)
table(newData$smallSet)
modelFil <- train(smallSet ~.,data=newData,method="glm")
typeod(newData)
typeof(newData)
typeof(newData[[1]])
typeof(newData[[2]])
newData[[1]]
newData$smallSet = as.factor(newData$smallSet)
head(newData)
modelFil <- train(smallSet ~.,data=newData,method="glm")
head(newData)
newData$smallSet2 = as.factor(newData$smallSet2)
modelFil <- train(smallSet2 ~.,data=newData,method="glm")
install.packages("e1071")
modelFil <- train(smallSet2 ~.,data=newData,method="glm")
modelFil
newData = cbind(smallSet2,smallSet)
head(newData)
newData$smallSet2 = as.factor(newData$smallSet2)
modelFil <- train(smallSet2 ~.,data=newData,method="glm")
modelFil
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
smallSet <- training[,(58:69)]
preProc = preProcess(log10(smallSet)+1),method="pca")
preProc = preProcess(log10(smallSet2[,-1])+1),method="pca")
preProc = preProcess((smallSet2[,-1]),method="pca")
preProc = preProcess(smallSet2[,-1],method="pca")
preProc = preProcess(smallSet2[,-1],method="pca",)
preProc = prcomp(smallSet)
preProc
trainPC = predict(preProc,smallSet)
trainPC
install "KernSmooth"
install KernSmooth
install.packages("KernSmooth")
help KernSmooth
library("KernSmooth")
add2 <- function(x,y){
x + y
}
add2(3,4)
above <- function(x,n){
use <- x>n
x[use]
}
x <- 1:11
x
y <- 8
above(x,y)
formals(above)
f <- function(a,b){
print(a)
print(b)
print(a)
}
f(45)
args(above)
search()
f <- function(x){
g <- function(y){
y+x
}
z <-4
x + g(x)
}
z <-10
f(3)
f <- function(x){
g <- function(y){
y+z
}
z <-4
x + g(x)
}
f(3)
setwd("C:/Users/Cyndi/Documents/Git Repositories/ProgrammingAssignment2")
